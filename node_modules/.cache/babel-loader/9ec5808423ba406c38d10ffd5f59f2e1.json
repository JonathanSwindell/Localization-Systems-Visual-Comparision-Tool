{"ast":null,"code":"'use strict';\n\nmodule.exports = Point;\n\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\nPoint.prototype = {\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone: function () {\n    return new Point(this.x, this.y);\n  },\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add: function (p) {\n    return this.clone()._add(p);\n  },\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub: function (p) {\n    return this.clone()._sub(p);\n  },\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint: function (p) {\n    return this.clone()._multByPoint(p);\n  },\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint: function (p) {\n    return this.clone()._divByPoint(p);\n  },\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  mult: function (k) {\n    return this.clone()._mult(k);\n  },\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div: function (k) {\n    return this.clone()._div(k);\n  },\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate: function (a) {\n    return this.clone()._rotate(a);\n  },\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround: function (a, p) {\n    return this.clone()._rotateAround(a, p);\n  },\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult: function (m) {\n    return this.clone()._matMult(m);\n  },\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit: function () {\n    return this.clone()._unit();\n  },\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp: function () {\n    return this.clone()._perp();\n  },\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round: function () {\n    return this.clone()._round();\n  },\n  /**\n   * Return the magitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag: function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals: function (other) {\n    return this.x === other.x && this.y === other.y;\n  },\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist: function (p) {\n    return Math.sqrt(this.distSqr(p));\n  },\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr: function (p) {\n    var dx = p.x - this.x,\n      dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  },\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle: function () {\n    return Math.atan2(this.y, this.x);\n  },\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo: function (b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  },\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith: function (b) {\n    return this.angleWithSep(b.x, b.y);\n  },\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin(θ) for θ.\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep: function (x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  },\n  _matMult: function (m) {\n    var x = m[0] * this.x + m[1] * this.y,\n      y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _add: function (p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  },\n  _sub: function (p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  },\n  _mult: function (k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  },\n  _div: function (k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  },\n  _multByPoint: function (p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  },\n  _divByPoint: function (p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  },\n  _unit: function () {\n    this._div(this.mag());\n    return this;\n  },\n  _perp: function () {\n    var y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  },\n  _rotate: function (angle) {\n    var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      x = cos * this.x - sin * this.y,\n      y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _rotateAround: function (angle, p) {\n    var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n      y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _round: function () {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (a) {\n  if (a instanceof Point) {\n    return a;\n  }\n  if (Array.isArray(a)) {\n    return new Point(a[0], a[1]);\n  }\n  return a;\n};","map":{"version":3,"names":["module","exports","Point","x","y","prototype","clone","add","p","_add","sub","_sub","multByPoint","_multByPoint","divByPoint","_divByPoint","mult","k","_mult","div","_div","rotate","a","_rotate","rotateAround","_rotateAround","matMult","m","_matMult","unit","_unit","perp","_perp","round","_round","mag","Math","sqrt","equals","other","dist","distSqr","dx","dy","angle","atan2","angleTo","b","angleWith","angleWithSep","cos","sin","convert","Array","isArray"],"sources":["/Users/jonathanswindell/Documents/Base/Academics/2022-2023 Senior/Spring Semester/CPE 496 Senior Design 2/ReactImplementation/gps_free_localization_visualization/node_modules/@mapbox/point-geometry/index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Point;\n\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone: function() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add:     function(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub:     function(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint:    function(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint:     function(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    mult:    function(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    div:     function(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate:  function(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {Array<Number>} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult: function(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit:    function() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp:    function() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round:   function() { return this.clone()._round(); },\n\n    /**\n     * Return the magitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {Number} magnitude\n     */\n    mag: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals: function(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    dist: function(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    distSqr: function(p) {\n        var dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {Number} angle\n     */\n    angle: function() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleTo: function(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleWith: function(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /*\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * @param {Number} x the x-coordinate\n     * @param {Number} y the y-coordinate\n     * @return {Number} the angle in radians\n     */\n    angleWithSep: function(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    _matMult: function(m) {\n        var x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _add: function(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    _sub: function(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    _mult: function(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    _div: function(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    _multByPoint: function(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    _divByPoint: function(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit: function() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp: function() {\n        var y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    _rotate: function(angle) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _rotateAround: function(angle, p) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round: function() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (a) {\n    if (a instanceof Point) {\n        return a;\n    }\n    if (Array.isArray(a)) {\n        return new Point(a[0], a[1]);\n    }\n    return a;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}