{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tqd0002/Documents/GitHub/TelemetryVisualization/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { optional } from \"./accessors.js\";\nimport { Node, computeHeight } from \"./hierarchy/index.js\";\nvar preroot = {\n    depth: -1\n  },\n  ambiguous = {},\n  imputed = {};\nfunction defaultId(d) {\n  return d.id;\n}\nfunction defaultParentId(d) {\n  return d.parentId;\n}\nexport default function () {\n  var id = defaultId,\n    parentId = defaultParentId,\n    path;\n  function stratify(data) {\n    var nodes = Array.from(data),\n      currentId = id,\n      currentParentId = parentId,\n      n,\n      d,\n      i,\n      root,\n      parent,\n      node,\n      nodeId,\n      nodeKey,\n      nodeByKey = new Map();\n    if (path != null) {\n      var I = nodes.map(function (d, i) {\n        return normalize(path(d, i, data));\n      });\n      var P = I.map(parentof);\n      var S = new Set(I).add(\"\");\n      var _iterator = _createForOfIteratorHelper(P),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _i = _step.value;\n          if (!S.has(_i)) {\n            S.add(_i);\n            I.push(_i);\n            P.push(parentof(_i));\n            nodes.push(imputed);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      currentId = function currentId(_, i) {\n        return I[i];\n      };\n      currentParentId = function currentParentId(_, i) {\n        return P[i];\n      };\n    }\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n    if (!root) throw new Error(\"no root\");\n\n    // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n      for (var _i2 = nodes.length - 1; _i2 >= 0; --_i2) {\n        node = nodes[_i2];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n    root.parent = preroot;\n    root.eachBefore(function (node) {\n      node.depth = node.parent.depth + 1;\n      --n;\n    }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n    return root;\n  }\n  stratify.id = function (x) {\n    return arguments.length ? (id = optional(x), stratify) : id;\n  };\n  stratify.parentId = function (x) {\n    return arguments.length ? (parentId = optional(x), stratify) : parentId;\n  };\n  stratify.path = function (x) {\n    return arguments.length ? (path = optional(x), stratify) : path;\n  };\n  return stratify;\n}\n\n// To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\nfunction normalize(path) {\n  path = \"\".concat(path);\n  var i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : \"/\".concat(path);\n}\n\n// Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" ⇥ \"/foo\", \"/foo\" ⇥ \"/\", \"/\" ↦ \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\nfunction parentof(path) {\n  var i = path.length;\n  if (i < 2) return \"\";\n  while (--i > 1) if (slash(path, i)) break;\n  return path.slice(0, i);\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    var k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}","map":{"version":3,"names":["optional","Node","computeHeight","preroot","depth","ambiguous","imputed","defaultId","d","id","defaultParentId","parentId","path","stratify","data","nodes","Array","from","currentId","currentParentId","n","i","root","parent","node","nodeId","nodeKey","nodeByKey","Map","I","map","normalize","P","parentof","S","Set","add","_iterator","_createForOfIteratorHelper","_step","s","done","value","has","push","err","e","f","_","length","set","get","Error","children","eachBefore","x","arguments","concat","slash","slice","k"],"sources":["/Users/tqd0002/Documents/GitHub/TelemetryVisualization/node_modules/d3-hierarchy/src/stratify.js"],"sourcesContent":["import {optional} from \"./accessors.js\";\nimport {Node, computeHeight} from \"./hierarchy/index.js\";\n\nvar preroot = {depth: -1},\n    ambiguous = {},\n    imputed = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nexport default function() {\n  var id = defaultId,\n      parentId = defaultParentId,\n      path;\n\n  function stratify(data) {\n    var nodes = Array.from(data),\n        currentId = id,\n        currentParentId = parentId,\n        n,\n        d,\n        i,\n        root,\n        parent,\n        node,\n        nodeId,\n        nodeKey,\n        nodeByKey = new Map;\n\n    if (path != null) {\n      const I = nodes.map((d, i) => normalize(path(d, i, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n      for (const i of P) {\n        if (!S.has(i)) {\n          S.add(i);\n          I.push(i);\n          P.push(parentof(i));\n          nodes.push(imputed);\n        }\n      }\n      currentId = (_, i) => I[i];\n      currentParentId = (_, i) => P[i];\n    }\n\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n\n    // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        node = nodes[i];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = optional(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = optional(x), stratify) : parentId;\n  };\n\n  stratify.path = function(x) {\n    return arguments.length ? (path = optional(x), stratify) : path;\n  };\n\n  return stratify;\n}\n\n// To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\nfunction normalize(path) {\n  path = `${path}`;\n  let i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : `/${path}`;\n}\n\n// Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" ⇥ \"/foo\", \"/foo\" ⇥ \"/\", \"/\" ↦ \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\nfunction parentof(path) {\n  let i = path.length;\n  if (i < 2) return \"\";\n  while (--i > 1) if (slash(path, i)) break;\n  return path.slice(0, i);\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}